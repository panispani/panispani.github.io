<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://panispani.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://panispani.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-12T13:22:55+00:00</updated><id>https://panispani.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">sanitext – Remove LLM-generated Text Fingerprints</title><link href="https://panispani.github.io/blog/2025/sanitext/" rel="alternate" type="text/html" title="sanitext – Remove LLM-generated Text Fingerprints"/><published>2025-03-11T00:00:00+00:00</published><updated>2025-03-11T00:00:00+00:00</updated><id>https://panispani.github.io/blog/2025/sanitext</id><content type="html" xml:base="https://panispani.github.io/blog/2025/sanitext/"><![CDATA[ <h2 id="the-hidden-fingerpint">The Hidden Fingerpint</h2> <p>How many differences can you spot between these two?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- I'm AI.            (Normal text)
− І’m󠅘󠅟󠅜󠅑 ΑІ.󠅓󠅙󠅑󠅟            (AI-tainted text)
</code></pre></div></div> <p>You probably noticed that the second quote looks a bit different? Actually, every single character in the second string is "tainted" in some way!</p> <ul> <li><code class="language-plaintext highlighter-rouge">−</code> (U+2212) is a minus sign instead of a hyphen</li> <li><code class="language-plaintext highlighter-rouge"> </code> (U+2009) is thin space</li> <li><code class="language-plaintext highlighter-rouge">І</code> (U+406) is a cyrillic letter instead of the latin “I”</li> <li><code class="language-plaintext highlighter-rouge">’</code> (U+2019) is a right single quoation mark instead of a regular quote <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup></li> <li><code class="language-plaintext highlighter-rouge">m󠅘󠅟󠅜󠅑</code> is the letter ‘m’ followed by hidden variation selectors, which encode the message "hola" (more info <a href="https://paulbutler.org/2025/smuggling-arbitrary-data-through-an-emoji/">here</a>)</li> <li><code class="language-plaintext highlighter-rouge"> </code> (U+2009) is thin space</li> <li><code class="language-plaintext highlighter-rouge">Α</code> (U+391) is a greek letter</li> <li><code class="language-plaintext highlighter-rouge">І</code> (U+406) is cyrillic</li> <li><code class="language-plaintext highlighter-rouge">.󠅓󠅙󠅑󠅟</code> is the period ‘.’ with the encoded message "ciao" using variation selectors</li> </ul> <p>You’d never notice these with the naked eye, but they could be used to detect AI-generated text.</p> <p>Which raises the question: if you mostly need an LLM to generate <strong>ASCII</strong> (code, emails, ..), why allow unnecessary Unicode? And if you do need specific Unicode characters, why not just <strong>explicitly define</strong> which ones?</p> <p><strong>Will Paste Special (Cmd+Shift+V) Fix This?</strong> In some apps, "Paste Special" strips formatting and replaces fancy typography with plain ASCII. But it <strong>won’t always remove invisible characters or homoglyphs</strong>. For example, I tried <strong>Paste Special</strong> in Sublime Text, and nothing was removed—but the thin space (U+2009) was clearly visible.</p> <h3 id="why-i-built-this"><strong>Why I Built This</strong></h3> <p>This isn’t a claim that major LLMs do all (or any) of these tricks. That said, I started working on this because I <strong>accidentally</strong> discovered an instance of text fingerprinting while debugging a byte-sensitive bug. That’s when I realized: it’s time to say goodbye to (at least these kinds of) fingerprints for good. 🙂</p> <p>Even if the LLM itself doesn’t add these, a wrapper around it might. This tool is for anyone who wants <strong>clean, reliable text</strong>, free from invisible garbage hiding inside.</p> <p>Edit: I’ve definitely come across random variation selectors from time to time. Otherwise, the most common case is typography: like em-dashes instead of hyphens, curly apostrophes, etc. If you’re feeding LLM output into a search tool, these subtle differences might not work in your favor (unless you always use fancy typography)!<br/> Also, your “writing signature” shifts when you go from never using proper typography to suddenly using it flawlessly, especially within a longer piece, or a series of tweets where only some follow these rules.</p> <h2 id="zooming-out-watermarks--fingerprints"><strong>Zooming out: Watermarks &amp; Fingerprints</strong></h2> <p>AI-generated content, in general, can be <em>marked</em>, sometimes invisibly, to identify its origin. A few examples:</p> <ul> <li> <p><strong>Latent Space Fingerprints</strong> - AI models leave behind subtle statistical patterns. Their text generation follows a probability distribution, creating a kind of <strong>stochastic signature</strong> (e.g., by occasionally using certain rare words).</p> </li> <li> <p><strong>Watermarking</strong> – Models can sneak in patterns in text, images, or audio. Think of it as an AI signature, hidden but detectable.</p> </li> <li> <p><strong>Metadata Encoding</strong> – Some AI-generated media comes with metadata baked in (e.g., image EXIF data).</p> </li> <li> <p><strong>Steganography</strong> – Messages can be embedded within the output, only detectable with the right key.</p> </li> </ul> <h2 id="the-problem-llm-systems-can-fingerprint-their-outputs-with-unicode-shenanigans"><strong>The Problem: LLM systems can Fingerprint their Outputs with Unicode Shenanigans</strong></h2> <p>LLM systems can inject subtle fingerprints into their outputs using Unicode tricks. These can include homoglyphs (characters that look identical but aren’t), invisible characters, and other Unicode weirdness–all embedded in AI-generated text for later detection.</p> <p>If AI-generated text is secretly marked, your emails, reports, or even tweets might be screaming "AI-generated" without you realizing it–though a filter might.</p> <h2 id="how-do-i-remove-this-sanitext"><strong>How do I remove this: <code class="language-plaintext highlighter-rouge">sanitext</code></strong></h2> <p><code class="language-plaintext highlighter-rouge">sanitext</code> is a simple command-line tool and Python library that:</p> <p>✔ <strong>Detects</strong> suspicious Unicode characters (defaults to ASCII-only)<br/> ✔ <strong>Normalizes</strong> lookalike characters to ASCII equivalents<br/> ✔ <strong>Removes</strong> characters with no lookalikes<br/> ✔ <strong>Supports</strong> custom character allowlists (<code class="language-plaintext highlighter-rouge">--allow-chars</code>, <code class="language-plaintext highlighter-rouge">--allow-file</code>)<br/> ✔ <strong>Works with your clipboard</strong>-no manual pasting needed (unless you want to)</p> <h2 id="how-it-works"><strong>How It Works</strong></h2> <p><code class="language-plaintext highlighter-rouge">sanitext</code> cleans up funky Unicode text using <strong>Unicode normalization (NFKC)</strong>, <strong>homoglyph mapping</strong>, and a <strong>special cleanup process</strong>: if not a <a href="https://github.com/panispani/sanitext/blob/main/sanitext/homoglyph_map.py">known homoglyph</a>, decompose the Unicode character and check for ASCII characters in the decomposition, e.g., <code class="language-plaintext highlighter-rouge">ﬁ</code> (U+FB01) decomposes to <code class="language-plaintext highlighter-rouge">f</code> + <code class="language-plaintext highlighter-rouge">i</code>.</p> <p>It also <strong>flags suspicious characters</strong> so you can see exactly what’s causing trouble. You can also allow specific Unicode characters or single-codepoint emojis.</p> <h3 id="-install-in-seconds"><strong>🚀 Install in Seconds</strong></h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>sanitext
</code></pre></div></div> <p>Now you can use it straight from the command line.</p> <h2 id="cli-usage-example">CLI usage example</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Process the clipboard content &amp; copy back to clipboard</span>
sanitext
<span class="c"># Detect characters but don't modify</span>
sanitext <span class="nt">--detect</span>
<span class="c"># Process clipboard + show detected characters (most common command)</span>
sanitext <span class="nt">-v</span>
<span class="c"># Process clipboard + show input, detected characters &amp; output</span>
sanitext <span class="nt">-vv</span>
<span class="c"># Process the provided string and print it</span>
sanitext <span class="nt">--string</span> <span class="s2">"Héllø, 𝒲𝑜𝓇𝓁𝒹!"</span>
<span class="c"># Allow additional characters (for now, only single unicode code point characters)</span>
sanitext <span class="nt">--allow-chars</span> <span class="s2">"αøñç"</span>
<span class="c"># Allow characters from a file</span>
sanitext <span class="nt">--allow-file</span> allowed_chars.txt
<span class="c"># Allow single code point emoji</span>
sanitext <span class="nt">--allow-emoji</span>
<span class="c"># Prompt user for handling disallowed characters</span>
<span class="c"># y (Yes) -&gt; keep it</span>
<span class="c"># n (No) -&gt; remove it</span>
<span class="c"># r (Replace) -&gt; provide a replacement character</span>
sanitext <span class="nt">--interactive</span>
<span class="c"># Allow emojis</span>
sanitext <span class="nt">--allow-emoji</span>
</code></pre></div></div> <h2 id="python-library-usage-example">Python library usage example</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">sanitext.text_sanitization</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">sanitize_text</span><span class="p">,</span>
    <span class="n">detect_suspicious_characters</span><span class="p">,</span>
    <span class="n">get_allowed_characters</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="sh">"</span><span class="s">“2×3 – 4 = 5”😎󠅒󠅟󠅣󠅣</span><span class="sh">"</span>

<span class="c1"># Detect suspicious characters
</span><span class="n">suspicious_characters</span> <span class="o">=</span> <span class="nf">detect_suspicious_characters</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Suspicious characters: </span><span class="si">{</span><span class="n">suspicious_characters</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># [('“', 'LEFT DOUBLE QUOTATION MARK'), ('×', 'MULTIPLICATION SIGN'), ('–', 'EN DASH'), ('”', 'RIGHT DOUBLE QUOTATION MARK')]
</span>
<span class="c1"># Sanitize text to all ASCII
</span><span class="n">sanitized_text</span> <span class="o">=</span> <span class="nf">sanitize_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Sanitized text: </span><span class="si">{</span><span class="n">sanitized_text</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># "2x3 - 4 = 5"
# Allow the multiplication sign
</span><span class="n">allowed_characters</span> <span class="o">=</span> <span class="nf">get_allowed_characters</span><span class="p">()</span>
<span class="n">allowed_characters</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="sh">"</span><span class="s">×</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sanitized_text</span> <span class="o">=</span> <span class="nf">sanitize_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">allowed_characters</span><span class="o">=</span><span class="n">allowed_characters</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Sanitized text: </span><span class="si">{</span><span class="n">sanitized_text</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># "2×3 - 4 = 5"
# Allow the emoji (but clean it from the encoded message "boss")
</span><span class="n">allowed_characters</span> <span class="o">=</span> <span class="nf">get_allowed_characters</span><span class="p">(</span><span class="n">allow_emoji</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">sanitized_text</span> <span class="o">=</span> <span class="nf">sanitize_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">allowed_characters</span><span class="o">=</span><span class="n">allowed_characters</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Sanitized text: </span><span class="si">{</span><span class="n">sanitized_text</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># "2x3 - 4 = 5"😎
</span></code></pre></div></div> <h3 id="-want-to-see-the-code"><strong>📂 Want to See the Code?</strong></h3> <p>Check out the code here: <a href="https://github.com/panispani/sanitext">https://github.com/panispani/sanitext</a>.<br/> Feel free to fork it, break it, improve it, or just use it to make your life easier.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p>The right single quotation mark <code class="language-plaintext highlighter-rouge">’</code>, while unusual on US keyboards, is automatically used to replace single quotes on iPhones if <strong>Smart Punctuation</strong> is enabled. However, I suspect that many of the long LinkedIn posts I notice this in weren’t written on an iPhone :) <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="LLM"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Molecular graph learning in the Optimal Transport Geometry</title><link href="https://panispani.github.io/blog/2021/Molecular-graph-learning-in-the-Optimal-Transport-Geometry/" rel="alternate" type="text/html" title="Molecular graph learning in the Optimal Transport Geometry"/><published>2021-04-20T00:00:00+00:00</published><updated>2021-04-20T00:00:00+00:00</updated><id>https://panispani.github.io/blog/2021/Molecular-graph-learning-in-the-Optimal-Transport-Geometry</id><content type="html" xml:base="https://panispani.github.io/blog/2021/Molecular-graph-learning-in-the-Optimal-Transport-Geometry/"><![CDATA[<h1 id="introduction">Introduction</h1> <h2 id="what">What</h2> <p>This blog post is short article about my master thesis “Molecular Graph Learning in the Optimal Transport Geometry” done at ETH Zurich under the supervision of Prof. Thomas Hofmann (ETH), Dr. Octavian Ganea (MIT) and Dr. Gary Bécigneul (ETH) (10/10/2020). Parts of this work were collaborative with Octav Dragoi (TUM) who was working on “Optimizing Molecular Graphs in the Wasserstein Space”. In this work, we are concerned with learning a latent space for molecular graphs and define a geometry to measure distances between molecules using Optimal Transport (<a href="https://en.wikipedia.org/wiki/Transportation_theory_(mathematics)">OT</a>). This latent space can be later used for downstream tasks such as generating molecules, property prediction or molecule optimization.</p> <h2 id="why">Why</h2> <p>In traditional computer-aided drug design (<em>CADD</em>), molecules formed with hand-crafted bond rules are enumerated and evaluated against some property of interest (e.g. obtaining more potent drugs with fewer side effects). While this technique has the advantage that it leaves us with knowledge of how to synthesize a molecule, it’s an untargeted search over a small subspace of the gigantic chemical space that remains vastly unexplored.</p> <p>More recent developments on <em>CADD</em> that use machine learning techniques \(\href{#3}{[3]} \href{#4}{[4]} \href{#5}{[5]}\), focus largely on learning a mapping from the discrete chemical space to a continuous lower-dimensional space and vice versa. This continuous latent space allows for downstream tasks such as molecular generation, optimization and property prediction.</p> <h1 id="chemistry-basics">Chemistry basics</h1> <p>In this work we model molecules as graphs with node attributes (e.g. atom type - Carbon/Oxygen/.., charge etc) and edge attributes (e.g. bond type - single/double/triple bond, depth etc). To use this abstraction we need to understand what constraints are necessary for a molecular graph to be a semantically valid molecule e.g. a carbon with \(0\) charge can form up to \(4\) bonds. Note that this is a simplification of reality (e.g. hypervalent atoms don’t follow the standard valency rules), but it’s common practice in chemoinformatics (e.g. see RDKit \(\href{#6}{[6]}\)).</p> <p>For chemistry-inclined audience, we are working with organic compounds with covalent bonds and charged atoms are formed using a solvent / dilution. All the molecules considered are in “Kekulized” form (we assign bond orders to aromatic bonds s.t. the valence constraints are satisfied) with Hydrogens removed.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/chem-basics-480.webp 480w,/assets/img/molgraphlearning/chem-basics-800.webp 800w,/assets/img/molgraphlearning/chem-basics-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/chem-basics.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Example molecule (acetonitrile). On the left we see a 3D visualization. On the right we see a molecular graph with node and edge features representing the molecule.</figcaption> </figure> <p>For a molecular graph to be semantically valid we require:</p> <ul> <li>Connectivity constraint: single connected component</li> <li>Valence constraint: degree constraint for every atom in the molecule e.g. Carbon (C) up to \(4\) bonds, Nitrogen (N) up to \(3\) etc</li> </ul> <p>Additionally, to compare with the generated molecules we use the following chemically-aware metrics:</p> <ul> <li>Tanimoto similarity coefficient \(\href{#1}{[1]}\): Chemical property similarity measure, uses Morgan fingerprints</li> <li>FCD \(\href{#2}{[2]} \href{#28}{[28]}\): Measures how close \(2\) molecular distributions are, using pertained latent representations of molecules</li> </ul> <h1 id="prior-work">Prior work</h1> <p>We do a quick review of prior work that learns a latent space for molecules for generation, optimization and property prediction. In generation they model the distribution of the latent space, in optimization they optimize on the latent space w.r.t. some property and in property prediction they use the latent space to get pertained embeddings.</p> <h2 id="string-representations-of-moleculels-smiles-selfies">String representations of moleculels (SMILES, SELFIES)</h2> <p>Represent molecules as strings using some parsing algorithm on top of the molecular graph \(\href{#16}{[16]} \href{#17}{[17]} \href{#18}{[18]} \href{#19}{[19]} \href{#20}{[20]}\).</p> <p>Pros/Cons:</p> <ul> <li>(+) Re-use SOTA NLP methods</li> <li>(-) String representations are not designed to capture molecular similarity, chemically similar molecules can have very different string representations</li> <li>(-) Seq2Seq / Transformer methods on top of strings are not permutation invariant w.r.t. graph nodes</li> </ul> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/smiles-example-480.webp 480w,/assets/img/molgraphlearning/smiles-example-800.webp 800w,/assets/img/molgraphlearning/smiles-example-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/smiles-example.png" width="25%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">SMILES string for a particular molecule</figcaption> </figure> <h2 id="autoregressive-approaches">Autoregressive approaches</h2> <p>Autoregressive approaches operate on graphs. They assume a node or edge ordering and encode/decode molecules according to the ordering \(\href{#21}{[21]} \href{#22}{[22]} \href{#23}{[23]} \href{#24}{[24]}\).</p> <p>Pros/Cons:</p> <ul> <li>(+) Can always generate valid molecules by filtering the allowed actions at each step</li> <li>(-) Not permutation invariant w.r.t. graph nodes</li> <li>(-) Problematic for big molecules (hard to model long-term dependencies)</li> </ul> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/autoregressive-480.webp 480w,/assets/img/molgraphlearning/autoregressive-800.webp 800w,/assets/img/molgraphlearning/autoregressive-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/autoregressive.png" width="55%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Generating a molecule atom-by-atom</figcaption> </figure> <h2 id="junction-tree-models">Junction Tree models</h2> <p>Junction tree models \(\href{#26}{[26]} \href{#4}{[4]}\) assume a fixed vocabulary of building blocks which can be combined to construct graphs. Encoding / decoding involves \(2\) steps: the tree structured skeleton of the molecule, the subgraph that is represented by each node in the tree graph.</p> <p>Pros/Cons:</p> <ul> <li>(+) Can enforce validity by filtering the predicted subgraphs</li> <li>(+) Can model bigger molecules easier than autoregressive approaches</li> <li>(-) Unclear what is the best vocabulary of subgraphs + limits the expressiveness of the model</li> <li>(-) Junction tree not unique and not guaranteed to exist</li> <li>(-) No permutation and isomorphism invariance</li> </ul> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/jt-480.webp 480w,/assets/img/molgraphlearning/jt-800.webp 800w,/assets/img/molgraphlearning/jt-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/jt.png" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Junction tree approach. The clusters (colored circles) are selected from a fixed vocabulary and are abstracted away, to form the Junction tree. Both the molecular graph and the Junction tree are separately encoded. The Junction tree is the first to be decoded. The decoded junction tree is combined with the molecular graph hidden representation to decode the clusters sequentially, selecting only the ones that will keep the molecule valid. Image taken from $$\href{#4}{[4]}$$</figcaption> </figure> <h2 id="our-approach">Our approach</h2> <p>Desired inductive biases:</p> <ul> <li>Permutation and isomorphism invariance w.r.t. graph nodes</li> <li>Decode semantically valid molecules</li> <li>No fixed vocabulary</li> <li>Operate on graphs</li> </ul> <p>To achieve this we perform one-shot prediction (from the latent representation to the graph), without introducing an ordering of the nodes. A big issue this method can have is that when nodes and edges are predicted jointly at once (needed for permutation and isomorphism invariance), generated graphs can be invalid e.g. disconnected graph.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/encoder-decoder-480.webp 480w,/assets/img/molgraphlearning/encoder-decoder-800.webp 800w,/assets/img/molgraphlearning/encoder-decoder-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/encoder-decoder.png" width="95%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">General Autoencoder pipeline. With our approach, we generate the graph $$\hat{G}$$ at once using the low-dimensional manifold assumption regarding the target molecular distribution.</figcaption> </figure> <p>Note: Regularized VAE \(\href{#11}{[11]}\) also generates valid molecules in one-shot by expressing discrete constraints in a differentiable manner. However, they achieve very low validity \(34.9\%\) and their approach is not permutation invariant (because of their loss function). We compare this with our approach in the \(\href{#experiments}{Experiments}\) section.</p> <h1 id="graph-encoder">Graph encoder</h1> <p>The molecular graph encoder uses a graph neural network to obtain node embeddings and then uses Deep Sets \(\href{#13}{[13]}\) i.e. add embeddings &amp; apply MLP on top, to obtain the molecular embedding.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/encoder-480.webp 480w,/assets/img/molgraphlearning/encoder-800.webp 800w,/assets/img/molgraphlearning/encoder-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/encoder.png" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <h1 id="graph-decoder---issues">Graph decoder - Issues</h1> <p>Unfortunately, there is no straightforward way to generate a graph from a vector in one shot. Recall that the decoder should preserve permutation invariance w.r.t. to graph nodes, and ensure semantic validity of generated graphs.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/decoder-480.webp 480w,/assets/img/molgraphlearning/decoder-800.webp 800w,/assets/img/molgraphlearning/decoder-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/decoder.png" width="70%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>To explain some of the ideas to tackle this, we will make a small introduction to <em>OT</em>.</p> <h1 id="optimal-transport-intro">Optimal Transport intro</h1> <p>Optimal transport (<em>OT</em>) studies the possible ways to morph a source measure \(\mu\) into a target measure \(\nu\), with special interest in the properties of the least costly way to achieve that and its efficient computation. Here we consider probability measures (with total volume \(1\)) and work with the Wasserstein distance and the Gromov-Wasserstein discrepancy.</p> <p>For simplicity, we assume that the measures are uniform over the sets they are defined over (equal mass at each point), and represent these uniform measures with pointclouds e.g. if a pointcloud has \(5\) points, each points carries \(0.2\) mass.</p> <h2 id="wasserstein-distance">Wasserstein distance</h2> <p>Wasserstein (<em>W</em>) distance takes \(2\) such pointclouds in the same metric measure space (but possibly of different number of points) and a cost function \(c\) (e.g. <em>L2</em>), and finds the optimal way to morph one into the other.</p> \[\begin{equation} \mathcal{W}(\mathbf{X}, \mathbf{Y}) = \min_{\mathbf{T}\in {\mathcal{C}}_{\mathbf{X} \mathbf{Y}}} \sum_{ij} \mathbf{T}_{ij} \, c(\mathbf{x}_i, \mathbf{y}_j) \end{equation}\] <p>where Transport plan \(\mathbf{T}\) is a doubly stoachastic matrix, and \(c(\mathbf{x}_i, \mathbf{y}_j)\) is the cost of transporting mass from \(\mathbf{x}_i\) to \(\mathbf{y}_j\).</p> <h2 id="gromov-wasserstein-discrepancy">Gromov-Wasserstein discrepancy</h2> <p>Wasserstein distance needs a ground cost function \(c\) to compare two points and thus can not be defined if those points are not defined on the same underlying space - or if we cannot preregister these spaces and define a cost between each pair of points of the two spaces.</p> <p>Gromov-Wasserstein (<em>GW</em>) discrepancy addresses this limitation by using two matrices \(\mathbf{A}\), \(\mathbf{B}\) to quantify similiarity relationships within the two different metric measure spaces, \(\mathcal{X}\) and \(\mathcal{Y}\) respectively. This way we can relate graphs in terms of their structure e.g. comparing their shortest distance matrices.</p> \[\begin{equation} \mathcal{GW}(\mathbf{A}, \mathbf{B}) = \min_{\mathbf{T} \in \mathcal{C}_{\mathcal{X} \mathcal{Y}}} \sum\limits_{ij} \sum\limits_{kl} \mathbf{T}_{ij} \mathbf{T}_{kl} \, c(\mathbf{A}_{ik}, \mathbf{B}_{jl}) \end{equation}\] <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/gw-480.webp 480w,/assets/img/molgraphlearning/gw-800.webp 800w,/assets/img/molgraphlearning/gw-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/gw.png" width="65%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <h1 id="graph-decoder---dictionary-learning-idea">Graph decoder - Dictionary learning idea</h1> <p>Xu H. \(\href{#10}{[10]}\) proposed a generalization of dictionary learning for graphs. The idea is that every graph is expressed as a Fréchet mean (GW Barycenter) of learnable dictionary elements and \(\lambda\) represents the weights of the dictionary elements.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/graph-decoder-dictionary-learning-480.webp 480w,/assets/img/molgraphlearning/graph-decoder-dictionary-learning-800.webp 800w,/assets/img/molgraphlearning/graph-decoder-dictionary-learning-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/graph-decoder-dictionary-learning.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Dictionary learning for molecules, adapted from the idea in $$\href{#10}{[10]}$$</figcaption> </figure> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/graph-decoder-dictionary-learning-manifold-480.webp 480w,/assets/img/molgraphlearning/graph-decoder-dictionary-learning-manifold-800.webp 800w,/assets/img/molgraphlearning/graph-decoder-dictionary-learning-manifold-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/graph-decoder-dictionary-learning-manifold.png" width="70%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Fréchet mean could be used with a generalized notion of distance (Wasserstein or Gromov-Wasserstein) to define the barycenter as an approximation of a molecule on a given graph manifold</figcaption> </figure> <p>Caveats: GW Barycenter is hard to backpropagate through. Also we need to combine <em>W</em> and <em>GW</em> to decompose a graph with node and edge features and this has a lot of free parameters. We alternatively do something simpler and easier to train, but keep the idea of dictionary learning.</p> <h1 id="graph-decoder---dictionary-learning-point-clouds">Graph decoder - Dictionary learning point clouds</h1> <p>Instead of going from the molecular embedding to the molecule directly, we firstly generate a point cloud (node embedding set) from the embedding vector (<em>Vec2Set</em>) i.e. we perform dictionary learning on the pointcloud level, and then we predict the node and edge features.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/graph-decoder-alternative-480.webp 480w,/assets/img/molgraphlearning/graph-decoder-alternative-800.webp 800w,/assets/img/molgraphlearning/graph-decoder-alternative-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/graph-decoder-alternative.png" width="90%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>In <em>Vec2Set</em>, we wish to generate a pointcloud from a vector \(\lambda\) in a permutation invariant way. We use the dictionary learning idea discussed previously but on the node embedding level (therefore using the Wasserstein metric which is easier to backpropagate through than GW).</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/vec2set-1-480.webp 480w,/assets/img/molgraphlearning/vec2set-1-800.webp 800w,/assets/img/molgraphlearning/vec2set-1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/vec2set-1.png" width="90%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>We use \(\lambda\) as the weights and the point clouds / atoms / prototypes are free parameters to be learnt.</p> <p>With pointclouds \({\\{\mathbf{P}_i\\}}\_{i=1}^K\) and weights \(\lambda \in \Delta^{K-1}\) we can compute the permutation invariant Wasserstein barycenter \(\mathbf{B}\)</p> \[arg\min_{\mathbf{B}}\sum_{i=1}^{K} \lambda_i \mathcal{W}(\mathbf{B}, \mathbf{P}_i)\] <p>Regarding the number of nodes when decoding, we can memorize the number of input nodes and sample it on generation / optimization. This is equivalent to doing optimal transport based clustering, see \(\href{#8}{[8]}\).</p> <p>In practice this proves to be very slow and hard to train :( We resort to 2 simplified approaches.</p> <h2 id="singlewb">SingleWB</h2> <p>Assume the points in the point clouds have an apriori fixed matching. This is not too restrictive as these prototypes are free parameters and it doesn’t compromise the permutation invariance of the model. It just requires that all point clouds have the same size.</p> <p>\(arg\min_{\mathbf{B}}\sum_{i=1}^{K} \lambda_i \mathcal{W}(\mathbf{B}, \mathbf{P}\_i)\) simplifies to \(arg\min_{\mathbf{B}} \mathcal{W}(\mathbf{B}, \sum_{i=1}^{K} \lambda_i \mathbf{P}_i)\) since we don’t have to find the alignment between the point clouds, but only between their weighted average and the barycenter. Note that \(\mathbf{B}\) can have a different number of points than the point cloud weighted average, hence the Wasserstein barycenter is still required.</p> <h2 id="linear-interpolation">Linear Interpolation</h2> <p>We set \(\mathbf{B} = \sum_k \lambda_k \mathbf{P}_k\) by adding the extra embeddings together. While this feels like cheating we will see that it matches the performance of SingleWB while converging much faster and being much more stable in training.</p> <h2 id="non-dictionary-learning-mode">Non-dictionary learning mode</h2> <p>We a predict fixed size point cloud from the latent representation. Then add extra embeddings together to form the point cloud of desired size.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/vec2set-2-480.webp 480w,/assets/img/molgraphlearning/vec2set-2-800.webp 800w,/assets/img/molgraphlearning/vec2set-2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/vec2set-2.png" width="85%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>So we got rid of <em>OT</em> with Linear Interpolation and Non-dictionary learning? At least on this step yes. However, we don’t know the alignment of the generated pointcloud and of the generated molecule with the initial one, so we’ll need <em>OT</em> later :)</p> <h1 id="graph-decoder---from-pointcloud-to-discrete-graph">Graph decoder - From pointcloud to discrete graph</h1> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/step2-480.webp 480w,/assets/img/molgraphlearning/step2-800.webp 800w,/assets/img/molgraphlearning/step2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/step2.png" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>The following questions naturally arise:</p> <ol> <li> <p>How to predict features, i.e. go from node embedding set to a graph?</p> </li> <li> <p>How to define a permutation invariant loss?</p> </li> <li> <p>How to ensure the graph is a valid molecule?</p> </li> </ol> <h2 id="1-how-to-predict-features">1. How to predict features</h2> <p>On each reconstructed embedding \(u\), we apply a neural net \(\tilde{F}(u)\) to predict a softmax distribution over the corresponding node feature vector (atom type). Similarly we apply a neural net \(\tilde{E}(u,v)\) on pairs of embeddings to predict edges between two nodes.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/predict-features-480.webp 480w,/assets/img/molgraphlearning/predict-features-800.webp 800w,/assets/img/molgraphlearning/predict-features-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/predict-features.png" width="80%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <h2 id="2-how-to-define-a-permutation-invariant-loss">2. How to define a permutation invariant loss?</h2> <p>This is where <em>OT</em> comes back in to take care of permutation invariance. We match both nodes and edge features in a permutation invariant way using an <em>OT</em> pseudometric, the Fused Gromov-Wasserstein (<em>FGW</em>) \(\href{#14}{[14]}\) discrepancy. We express the loss function \(FGWLL_a(\mathbf{G}, \hat{\mathbf{G}})\), between input and reconstructed graphs \(\mathbf{G}\) and \(\hat{\mathbf{G}}\), using as cost functions \(c_1\), \(c_2\) the product of the log-likelihood of the target labels and a rescaling factor.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/fgw1-480.webp 480w,/assets/img/molgraphlearning/fgw1-800.webp 800w,/assets/img/molgraphlearning/fgw1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/fgw1.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/fgw2-480.webp 480w,/assets/img/molgraphlearning/fgw2-800.webp 800w,/assets/img/molgraphlearning/fgw2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/fgw2.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <h2 id="3-how-to-ensure-the-graph-is-a-valid-molecule">3. How to ensure the graph is a valid molecule?</h2> <p>This proves to be one of the hardest parts of the pipeline. We explore \(3\) methods.</p> <ul> <li>Argmax</li> <li>CRF for structured prediction on top of logits</li> <li>Penalty method to enforce discrete constraints</li> </ul> <h3 id="argmax">Argmax</h3> <p>Argmax is pretty self-explanatory and used as a comparative baseline. We just pick the most probable label from each separate predicted feature distribution.</p> <h3 id="crf-for-structured-prediction-on-top-of-logits">CRF for structured prediction on top of logits</h3> <p><em>CRFs</em> are undirected graphical models for structured prediction that model the conditional distribution \(P(y \| x)\), where \(y\) are the output variables and \(x\) the observed variables. The conditional distribution is modelled as the product of some factors, each of which depends on a subset of variables subject to normalization, \(P(\mathbf{y}\|\mathbf{x}) \propto \prod_f f(\mathbf{y}, \mathbf{x})\). In our case the observed variables are the logits and the output variables represent the final discretized reconstruction.</p> <p>We can view the node and edge attributes as random variables which have some dependencies e.g. a Carbon node can have at most \(4\) bonds. We aim to always predict valid molecules by performing structured prediction over the undirected <em>CRF</em>.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/fc-480.webp 480w,/assets/img/molgraphlearning/fc-800.webp 800w,/assets/img/molgraphlearning/fc-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/fc.png" width="55%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Example factor graph of an undirected graphical model. $$s_1$$..$$s_5$$ are the random variables and $$f_1$$..$$f_5$$ are the factors. Factors connect to random variables on which they depend on, and their product it proportional to the conditional distribution of output variables given the observed ones.</figcaption> </figure> <p>Belief propagation is an algorithm that can be used for inference in undirected graphical models. The algorithm is outlined below (initialize messages, iteratively update, compute marginals):</p> \[\begin{align*} &amp;\mu_{f\rightarrow s}^t(x) = \sum\limits_{\mathbf{x}_f / x} f(\mathbf{x}_f) \prod\limits_{x'\in N(f) / s} \mu_{x'\rightarrow f}^{t-1}({\mathbf{x}_f}_{x'}) \\[3pt] &amp;\mu_{s\rightarrow f}^t(x) = \prod\limits_{f'\in N(s) / f} \mu_{f'\rightarrow s}^{t-1}(x) \\[3pt] &amp;\text{Marginal: } \mathbf P(s=i) \propto \prod\limits_{f\in N(s)} \mu_{f\rightarrow s}^{\textbf{T}}(i) \end{align*}\] <p>The computational bottleneck of message passing lies in the \(\mu_{f \rightarrow s}\) message. It has complexity as big as the cardinality of all random variables in the factor \(f\).</p> <p>To make this process differentiable we don’t require the factors (potentials) to be differentiable, we unroll the algorithm \(\mathbf{T}\) times, place on top of network &amp; learn parameters of factors via backpropagation. The factors are used to whitelist combinations of labels and to plug-in the logits e.g. a Carbon node will never have \(2\) triple bonds but it’s very possible that is has \(2\) double bonds.</p> <p>For observed variables \(\tilde{F}(u)\) (node logits), \(\tilde{E}(u, v)\) (edge logits), output variables \(\hat{F}(u)\) (final nodes), \(\hat{E}(u, v)\) (final edges), we define the following factors (think of them as the dependencies between the variables):</p> \[\begin{equation*} \Psi_{node_i}(\tilde{F}(i)) = exp(w_{node} \tilde{F}(i)) \end{equation*}\] \[\begin{equation*} \Psi_{edge_{ij}}(\tilde{E}(i, j)) = exp(w_{edge} \tilde{E}(i, j)) \end{equation*}\] \[\begin{equation*} \Psi_{val_i}(\hat{F}(i), \hat{E}(i, j) \, \forall j \in \{1..i-1,i+1,..n\}) = \begin{cases} \text{1} &amp;\quad valency(\hat{F}(i)) \geq \sum\limits_j^n valency(\hat{E}(i, j))\\ \text{0} &amp;\quad \text{otherwise}\\ \end{cases} \end{equation*}\] \[\begin{equation*} \Psi_{conn}(\hat{E}(i, j) \, \forall i, j: i &lt; j \; i, j \in \{1..n\}) = \begin{cases} \text{1} &amp;\quad \text{BFS from a node can reach all others}\\ \text{0} &amp;\quad \text{otherwise}\\ \end{cases} \end{equation*}\] <p>For \(\mathbf{T}=10\) message passing iterations, connectivity is not tractable. Valency is tractable using pruning e.g. considering the top 6 most probable edges per node instead of all possible ones. Spoiler (or not): Valence enforcement works well but connectivity causes low validity overall with this method.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/crf-example-480.webp 480w,/assets/img/molgraphlearning/crf-example-800.webp 800w,/assets/img/molgraphlearning/crf-example-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/crf-example.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Example with a molecular graph of $$3$$ nodes. On the left we have a molecule with $$2$$ Carbon (C) nodes and $$1$$ Phosphorus (P) node. On the right, we have the undirected graphical model. In white we have the unobserved variables we want to perform structure prediction over. The red nodes is where the logits get fed and the blue nodes is where the label compatibility is being enforced</figcaption> </figure> <h3 id="penalty-method">Penalty method</h3> <p>The penalty method idea is to replace the constrained optimization problem, where the optimization constraints are discrete and non-differentiable (connectivity and valency over a discrete molecular graph), with an unconstrained problem which is formed by adding weighted penalty terms to the objective function. The idea in this context is to differentiably sample molecules from the predicted node/edge logits and add differentiable regularizing (penalty) terms to the training loss according to whether they satisfy the connectivity and valence constraints.</p> <p>We can differentiably sample from logits using Gumbel softmax, softmax with temperature etc. Here we show only softmax with temperature, as we got more stable training with it. We sample from logits \(z_i\) using a temperature \(\tau\). The smaller \(\tau\) is, the more one-hot are the post-softmax probabilities \(y_i\).</p> \[y_i = \frac{exp(\frac{z_i}{\tau})}{\sum_j exp(\frac{z_j}{\tau})}\] <blockquote> <p>Valence constraint penalty</p> </blockquote> <p>Compute for each node \(i\), the expected actual degree \(E(i)\) (from the predicted bonds) and the expected maximum degree \(M(i)\) (from the maximum valency of the predicted atom type). Also due to connectivity, the minimum degree is \(1\).</p> \[penalty_{valence} = \sum_{\text{node }i} min(0,\, 1 - E(i)) + min(0, \, E(i) - M(i))\] <blockquote> <p>Connectivity constraint penalty</p> </blockquote> <p>The Laplacian matrix \(\mathbf{L}\), is a matrix representation of the graph (\(\mathbf{E}_{ij}\) edges of sampled graph).</p> \[\mathbf{L}_{kl} = \begin{cases} \sum_{m \neq k} \mathbf{E}_{km} &amp; \text{, if } k = l,\\ -\mathbf{E}_{kl} &amp; \text{, if } k \neq l\end{cases}\] <p>Theorem\(\href{#12}{[12]}\): \(\mathbf{L}\) is symmetric and positive semidefinite. If \(L + \frac{1}{N}\mathbf{1}_N\mathbf{1}_N^T\) is strictly positive definite then the graph is connected. This happens when its eigenvalues are positive.</p> \[penalty_{connectivity} = log(\frac{cap\_value ^ N}{\prod_i eig_i})\] <p>All eigenvalues of \(\mathbf{L}\) are non-negative and we want to penalize all reasonably small eigenvalues. We select a “cap value”, which indicates the maximum eigenvalue value that we penalize, by extracting the minimum eigenvalue from molecular datasets. We also don’t want the eigenvalues to be too small (since we use log) so we clamp them from below to \(1e^{−8}\). The intuition is that the penalty will be 0 when the eigenvalues are all greater than the “cap value” and that we want an exponential loss for eigenvalues even slightly below the “cap value” - hence the log.</p> <blockquote> <p>Euler constraint penalty</p> </blockquote> <p>Since we work with 2D graphs we can use the Euler characteristic \(\|V\| - \|E\| + \|F\| = 2\). Since \(\|F\| = \|Cycles\| + 1\) and empirically \(99.9\%\) of the molecules have up to \(6\) cycles:</p> \[penalty_{euler} = min(0, |V| - 1 - |E|) + min(0, |E| - |V| - 5)\] <h1 id="experiments">Experiments</h1> <p>We mainly use ChEMBL [7], which is a molecular dataset of 430K molecules, with a 80-10-10 split.</p> <h2 id="validity">Validity</h2> <p>We need to decode chemically valid molecules otherwise this method can’t be used in either property prediction, generation or optimization. Also we can’t measure chemical similarity between datasets if the molecules are invalid. Below we show our results with the \(3\) different discretization strategies.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/table-1-480.webp 480w,/assets/img/molgraphlearning/table-1-800.webp 800w,/assets/img/molgraphlearning/table-1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/table-1.png" width="90%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>We see that with <em>Argmax</em>, we have the highest atom type accuracy (as expected, it has no regularizers), but have extremely low validity mainly caused by invalid valencies (invalid nodes). With the <em>CRF</em>, the validity is a bit higher as we manage to satisfy the valence constraints but get a lot of disconnected components. With the penalty method we manage to easily fit both and get \(99.9\%\) validity with a little lower atom type accuracy. Comparing the proposed graph decoders: using the full Wasserstein barycenter doesn’t converge, SingleWB converges, Linear Interpolation converges the fastest, non-dictionary learning performs at most as good as Linear Interpolation when tweaked well.</p> <h2 id="comparison-with-previous-attempt">Comparison with previous attempt</h2> <p>We compare our apporach with Regularizing VAE \(\href{#12}{[12]}\) where they attempt one-shot generation of valid molecules. They use the QM9 \(\href{#27}{[27]}\) (small molecules dataset) and ZINC \(\href{#9}{[9]}\) datasets.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/table-2-480.webp 480w,/assets/img/molgraphlearning/table-2-800.webp 800w,/assets/img/molgraphlearning/table-2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/table-2.png" width="70%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>QM9 is a dataset with very small molecules (molecules have up to 9 nodes). ZINC is a more realistic dataset where Regularized VAE doesn’t perform that well. We also note that MolGAN \(\href{#25}{[25]}\) is another previous attempt for generation on top of graph without autoregression. However, they also only report good results on QM9.</p> <h2 id="tanimoto-similarity">Tanimoto similarity</h2> <p>Our models don’t perform greatly regarding Tanimoto similarity. In ChEMBL we achieve Tanimoto similarity of \(10.1\%\) (chemical similarity of input and reconstructed molecules). We note that it’s easy for Tanimoto similarity to drop with the following example.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/tanimoto-example-480.webp 480w,/assets/img/molgraphlearning/tanimoto-example-800.webp 800w,/assets/img/molgraphlearning/tanimoto-example-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/tanimoto-example.png" width="40%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Easy for Tanimoto to drop, 1 bond difference and have $26.7\%$ similarity</figcaption> </figure> <p>Even though we manage to reconstruct molecules, if they aren’t chemically similar to the input dataset our autoencoder is of little use to downstream tasks. We investigate what causes Tanimoto to drop, by cutting off a part of the pipeline.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/tanimoto-pipeline-480.webp 480w,/assets/img/molgraphlearning/tanimoto-pipeline-800.webp 800w,/assets/img/molgraphlearning/tanimoto-pipeline-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/tanimoto-pipeline.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <p>Instead of collapsing to a single latent representation using Set2Vec we keep the node embeddings and decode directly. We remove therefore a part of the autoencoder (everything inside the black box). We know the node correspondences of the input and the output so we can also use L2 instead of FGW. Using FGW in this simplified setting (skipping everything inside the box), we still get \(10\%\) Tanimoto similarity. Using L2 we get Tanimoto \(&gt; 50\%\). This means that GNN embeddings are not too weak since L2 succeeds in recovering the node and edge features from them. FGW is not strong enough to correlate the independent predictions of node and edge types.</p> <h1 id="attempt-at-a-downstream-task">Attempt at a downstream task</h1> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/adversarial-480.webp 480w,/assets/img/molgraphlearning/adversarial-800.webp 800w,/assets/img/molgraphlearning/adversarial-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/adversarial.png" width="90%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption">Adversarial Autoencoder for generator from Gaussian noise</figcaption> </figure> <p>The FCD distance between the test dataset and a 1000 molecule generated dataset is too big (&gt; 100). Our autoencoder has little usefulness due to the low Tanimoto similarity.</p> <h1 id="future-work-idea---improving-the-tanimoto-similarity">Future work idea - improving the Tanimoto similarity</h1> <p>Instead of computing the FGW transport plan by solving an <em>OT</em> optimization problem, we can compute a cross attention matrix as described in \(\href{#15}{[15]}\) between the two pointclouds (input and reconstructed). We can use that cross attention matrix as a differentiable transport plan in the FGW loss instead of using <em>OT</em> solvers.</p> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/future-opt-480.webp 480w,/assets/img/molgraphlearning/future-opt-800.webp 800w,/assets/img/molgraphlearning/future-opt-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/future-opt.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <figure> <div style="text-align: center"> <picture> <source class="responsive-img-srcset" srcset="/assets/img/molgraphlearning/future-480.webp 480w,/assets/img/molgraphlearning/future-800.webp 800w,/assets/img/molgraphlearning/future-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/molgraphlearning/future.png" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </div> <figcaption class="caption"></figcaption> </figure> <h1 id="conclusion">Conclusion</h1> <p>In this work we manage to generate semantically valid graphs in a one-shot isomorphically and permutation invariant way. We achieve \(99.9\%\) validity on the ChEMBL dataset, much higher than previous attempts at the problem with highest validity \(&lt; 35\%\). We achieve this by enforcing discrete chemical constraints on graphs in a one-shot decoder. We observe, however, that the Tanimoto similarity of the decoded datasets and the input ones is not that high. Since we observe high node features accuracy (\(91.7\%\)) we attribute this to failing to learn the skeleton of the graph. This renders to be due to the OT loss we use, as it proves to be too weak to correlate the independent predictions of node and edge types. Due to the low Tanimoto similarity, this autoencoder doesn’t seem to be that useful in downstream tasks of property prediction, molecular generation and optimization. We believe that a way to improve the Tanimoto similarity could be to compute something similar to a transport matrix (replacing the FGW optimization problem), for example a differentiable cross attention matrix, which is easier to backpropagate through and can yield better results.</p> <p>And that’s it! Thanks for reading this far! Too bad, the application of OT wasn’t that successful after all :) Feel free to reach out if you’re working on something similar or just want to talk about this.</p> <p><br/></p> <p>Cited as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@article{panayiotou2021molgraphlearn,
  title   = "Molecular graph learning in the Optimal Transport Geometry",
  author  = "Panayiotou, Panayiotis and Ganea, Octavian and Dragoi, Octav and Hofmann, Thomas",
  journal = "https://panpan2.github.io/",
  year    = "2021",
  url     = "https://panpan2.github.io/2021/04/20/molecular-graph-learning-in-the-optimal-transport-geometry"
}
</code></pre></div></div> <h1 id="references">References</h1> <div id="1">[1] Tanimoto, T. T. IBM Internal Report; IBM Corporation: Armonk, NY, Nov 17, 1957.</div> <div id="2">[2] Kristina Preuer, Philipp Renz, Thomas Unterthiner, Sepp Hochreiter, Günter Klambauer. Fréchet ChemNet Distance: A metric for generative models for molecules in drug discovery, 2018</div> <div id="3">[3] Akshat Kumar Nigam, Pascal Friederich, Mario Krenn, and Alan Aspuru-Guzik. Augmenting genetic algorithms with deep neural networks for exploring the chemical space. 2019 </div> <div id="4">[4] Wengong Jin, Regina Barzilay, and Tommi S. Jaakkola. Junction tree variational autoencoder for molecular graph generation. CoRR, abs/1802.04364, 2018.</div> <div id="5">[5] Jimeng Sun Tianfan Fu, Cao Xiao. Core: Automatic molecule optimization using copy refine strategy. 2019.</div> <div id="6">[6] Greg Landrum et al. Rdkit: Open-source cheminformatics. 2006.</div> <div id="7">[7] Anna Gaulton, Louisa J. Bellis, A. Patricia Bento, Jon Chambers, Mark Davies, Anne Hersey, Yvonne Light, Shaun McGlinchey, David Michalovich, Bissan Al-Lazikani, and John P. Overington. ChEMBL: a large-scale bioactivity database for drug discovery. Nucleic Acids Research, 40(D1):D1100–D1107, 09 2011.</div> <div id="8">[8] Marco Cuturi and Arnaud Doucet. Fast computation of wasserstein barycenters, 2014.</div> <div id="9">[9] Teague Sterling and John J. Irwin. Zinc 15 – ligand discovery for everyone. Journal of Chemical Information and Modeling, 55(11):2324–2337, 2015. PMID: 26479676.</div> <div id="10">[10] Hongteng Xu. Gromov-wasserstein factorization models for graph clustering, 2019.</div> <div id="11">[11] Tengfei Ma, Jie Chen, and Cao Xiao. Constrained generation of semantically valid graphs via regularizing variational autoencoders. 09 2018.</div> <div id="12">[12] M. Sundin, A. Venkitaraman, M. Jansson, and S. Chatterjee. A connectedness constraint for learning sparse graphs. In 2017 25th European Signal Processing Conference (EUSIPCO), pages 151–155, 2017.</div> <div id="13">[13] Manzil Zaheer, Satwik Kottur, Siamak Ravanbakhsh, Barnabas Poczos, Russ R Salakhutdinov, and Alexander J Smola. Deep sets. In I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, editors, Advances in Neural Information Processing Systems 30, pages 3391–3401. Curran Associates, Inc., 2017.</div> <div id="14">[14] Titouan Vayer, Laetita Chapel, Remi Flamary, Romain Tavenard, and Nicolas Courty. Fused gromov-wasserstein distance for structured objects: theoretical foundations and mathematical properties, 2018.</div> <div id="15">[15] Francesco Locatello, Dirk Weissenborn, Thomas Unterthiner, Aravindh Mahendran, Georg Heigold, Jakob Uszkoreit, Alexey Dosovitskiy, and Thomas Kipf. Object-centric learning with slot attention, 2020.</div> <div id="16">[16] Matt J. Kusner, Brooks Paige, and Jose Miguel Hernandez-Lobato. Grammar variational autoencoder, 2017.</div> <div id="17">[17] Hanjun Dai, Yingtao Tian, Bo Dai, Steven Skiena, and Le Song. Syntaxdirected variational autoencoder for structured data, 2018.</div> <div id="18">[18] Benjamin Sanchez-Lengeling, Carlos Outeiral, Gabriel L. Guimaraes, and Alan Aspuru-Guzik. Optimizing distributions over molecular space. an objective-reinforced generative adversarial network for inverse-design chemistry (organic), Aug 2017.</div> <div id="19">[19] Esben Jannik Bjerrum and Richard Threlfall. Molecular generation with recurrent neural networks (rnns), 2017.</div> <div id="20">[20] David K Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Alan Aspuru-Guzik, and Ryan P Adams. Convolutional networks on graphs for learning molecular fingerprints. In C. Cortes, N. D. Lawrence, D. D. Lee, M. Sugiyama, and R. Garnett, editors, Advances in Neural Information Processing Systems 28, pages 2224– 2232. Curran Associates, Inc., 2015</div> <div id="21">[21] Martin Simonovsky and Nikos Komodakis. Graphvae: Towards generation of small graphs using variational autoencoders: 27th international conference on artificial neural networks, rhodes, greece, october 4-7, 2018, proceedings, part i. pages 412–422, 09 2018.</div> <div id="22">[22] Yujia Li, Oriol Vinyals, Chris Dyer, Razvan Pascanu, and Peter Battaglia. Learning deep generative models of graphs, 2018.</div> <div id="23">[23] Jiaxuan You, Rex Ying, Xiang Ren, William L. Hamilton, and J. Leskovec. Graphrnn: Generating realistic graphs with deep autoregressive models. In ICML, 2018.</div> <div id="24">[24] Aleksandar Bojchevski, Oleksandr Shchur, Daniel Zuegner, and Stephan Gunnemann. Netgan: Generating graphs via random walks. 03 2018</div> <div id="25">[25] Nicola De Cao and Thomas Kipf. Molgan: An implicit generative model for small molecular graphs, 2018.</div> <div id="26">[26] Wengong Jin, Regina Barzilay, and Tommi Jaakkola. Hierarchical generation of molecular graphs using structural motifs, 2020.</div> <div id="27">[27] L. C. Blum and J.-L. Reymond. 970 million druglike small molecules for virtual screening in the chemical universe database GDB-13. J. Am. Chem. Soc., 131:8732, 2009.</div> <div id="28">[28] Garrett B. Goh, Charles Siegel, Abhinav Vishnu, and Nathan O. Hodas. Using rule-based labels for weak supervised learning: A chemnet for transferable chemical property prediction, 2018.</div>]]></content><author><name></name></author><category term="ML"/><category term="GNN"/><category term="OT"/><category term="thesis"/><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>